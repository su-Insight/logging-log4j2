////
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
////

Error handling::
If a problem happens during the logging process and an exception is thrown, it is less easy for an asynchronous setting to signal this problem to the application.
This can partly be alleviated by configuring an exception handler, but this may still not cover all cases.

Stateful messages::
In some rare cases, care must be taken with mutable messages.
Most of the time you don't need to worry about this.
Log4 will ensure that log messages like `logger.debug("My object is {}", myObject)` will use the state of the `myObject` parameter at the time of the call to `logger.debug()`.
The log message will not change even if `myObject` is modified later.
It is safe to asynchronously log mutable objects because most xref:manual/messages.adoc[built-in `Message` implementations] take a snapshot of the parameters.
There are some exceptions however: xref:manual/messages.adoc#MapMessage[`MapMessage`] and xref:manual/messages.adoc#StructuredDataMessage[`StructuredDataMessage`] are mutable by design, fields can be added to these messages after the message object was created.
These messages should not be modified after they are logged with asynchronous loggers or asynchronous appenders; you may or may not see the modifications in the resulting log output.
Similarly, custom `Message` implementations should be designed with asynchronous use in mind, and either take a snapshot of their parameters at construction time, or document their thread-safety characteristics.

Computational overhead::
If your application is running in an environment where CPU resources are scarce, like a machine with one CPU with a single core, starting another thread is not likely to give better performance.

Appender performance::
If the sustained rate at which your application is logging messages is faster than the maximum sustained throughput of the underlying appender, the queue will fill up and the application will end up logging at the speed of the slowest appender. If this happens, consider selecting a faster appender, or logging less. If neither of these is an option, you may get better throughput and fewer latency spikes by logging synchronously.
