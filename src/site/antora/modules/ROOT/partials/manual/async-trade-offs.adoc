////
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
////

[#async-trade-offs]
= Trade-offs

There are certain trade-offs associated with asynchronous logging:

[#async-benefits]
== Benefits

Higher peak throughput::
Applications that occasionally need to log bursts of messages, can take advantage of asynchronous logging.
It can prevent or dampen latency spikes by shortening the wait time until the next message can be logged.
If the queue size is large enough to handle the burst, asynchronous logging will prevent your application from falling behind during a sudden increase of activity.

Lower logging latency::
link:../javadoc/log4j-api/org/apache/logging/log4j/Logger.html[Logger]
method calls return faster, since most of the work is done on the I/O thread.

[#async-drawbacks]
== Drawbacks

Lower sustainable throughput::
If the _sustained rate_ at which your application is logging messages is faster than the maximum sustained throughput of the underlying appender, the queue will fill up and the application will end up logging at the speed of the slowest appender.
If this happens, consider selecting a faster appender, or logging less.
If neither of these is an option, you may get better throughput and fewer latency spikes by logging synchronously.

Error handling::
If a problem happens during the logging process and an exception is thrown, it is less easy for an asynchronous setting to signal this problem to the application.
This can partly be alleviated by configuring an exception handler, but this may still not cover all cases.

Stateful messages::
In some rare cases, care must be taken with mutable messages.
Most of the time you don't need to worry about this.
Log4 will ensure that log messages like `logger.debug("My object is {}", myObject)` will use the state of the `myObject` parameter at the time of the call to `logger.debug()`.
The log message will not change even if `myObject` is modified later.
It is safe to asynchronously log mutable objects because most xref:manual/messages.adoc[built-in `Message` implementations] take a snapshot of the parameters on the calling thread (see xref:manual/systemproperties.adoc#log4j2.formatMsgAsync[`log4j2.formatMsgAsync`]).
+
There are some exceptions however: xref:manual/messages.adoc#MapMessage[`MapMessage`] and xref:manual/messages.adoc#StructuredDataMessage[`StructuredDataMessage`] are mutable by design, fields can be added to these messages after the message object was created.
These messages should not be modified after they are logged with asynchronous loggers or asynchronous appenders; you may or may not see the modifications in the resulting log output.
+
Similarly, custom
link:../javadoc/log4j-api/org/apache/logging/log4j/message/Message.html[`Message`]
implementations should be designed with asynchronous use in mind, and either take a snapshot of their parameters at construction time, or document their thread-safety characteristics (see
link:../javadoc/log4j-api/org/apache/logging/log4j/message/AsynchronouslyFormattable.html[`AsynchronouslyFormattable`]).

Computational overhead::
If your application is running in an environment where CPU resources are scarce, like a VM with a single vCPU, starting another thread is not likely to give better performance.
